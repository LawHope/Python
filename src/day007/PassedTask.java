package day007;

public class PassedTask {
}
/*
            <단축키!!!!!!!!!!!!>

        maven, gradle
group id = 그룹 아이디, 예를 들면 스프링
artifact id = 모듈 이름, 예를 들면 스프링 시큐리티, 스프링 MVC

액션 검색 : meta + shift + a
새로 만들기 : meta + n
현재포커스 실행 : ctrl + shift + r
이전포커스 실행 : ctrl + r

라이브 템플릿
메인메서드 : psvm
System.out.println : sout

라인 복제하기 : meta + d
라인 삭제하기 : meta + delete
문자열 라인 합치기 : ctrl + shift + j
라인 단위로 옮기기 :

문법 상관하면서 : meta + shift + up/down
문법 상관없이 : option + shift + up/down
element 단위로 옮기기(html, xml 속성, 메서드 매개변수 순서 등등) : meta + option + shift + left/right
파라미터 즉시보기 : meta + p
코드 구현부 즉시보기 : option + space
docs 보기 : f1

단어별 이동 : alt + 좌우(선택 : +shift)
라인 첫/끝 : fn + 좌우(선택 : +shift)
page up/down : fn + 위아래

포커스 범위(선택) 한 단계씩 늘리기 : alt + 위아래
포커스 앞/뒤 : meta + [/]
멀티포커스 : alt + alt + 위/아래(리눅스는 ctrl)
오류라인 자동 포커스 : f2

리팩토링
변수추출
똑같은 값들을 하나의 변수로 추출하는 과정
추출하고자 하는 값을 선택한 뒤, command + option + v

파라미터 추출
command + option + p
변수가 아니라 파라미터로 추출된다
extract via overloading method를 사용하면 추출된 메서드를

메서드 추출
추출하고 싶은 만큼 코드를 선택한 다음 command + option + m

이너클래스 추출
이너클래스가 여러군데서 사용될 떄 외부클래스로 추출할 수 있다
f6 번을 누르면 어떻게 이동시킬지 선택할 수 있는 부분이 나오고, 여기서 이동할 패키지를 지정해주면 깔끔하게 클래스가 이동된다

이름 일괄 변경
shift + f6
변수 이름 외에, 메서드 이름, 클래스 이름 모두 적용 가능

타입 일괄변경
파라미터 리턴 타입에 마우스대고 cmd + shift + 6
반환하는 값에 대해서는 자동 변환시키거나 직접 설정가능

사용하지 않는 import 제거
ctrl + option + o
command shitf a + optimize import 부분을 off -> on으로 바꾸면 자동으로 사용하지 않는 import를 정리해준다
파일을 열떄마다 자동으로 사라지게 해준다
이 기능을 사용하면 import문을 * 으로 변경하는 경우가 많은데,
action -> import with * 의 개수를 999로 설정하면 해결된다

정렬되지 않은 코드 정렬
command + option + l





<인스턴스(instance)>
자바에서 클래스를 사용하기 위해서는 우선 해당 클래스 타입의 객체(object)를 선언해야 합니다.
이렇게 클래스로부터 객체를 선언하는 과정을 클래스의 인스턴스 화라고 합니다.
또한, 이렇게 선언된 해당 클래스 타입의 객체를 인스턴스(instance)라고 합니다.1
즉, 인스턴스란 메모리에 할당된 객체를 의미합니다.



                               <<연산자!!!!!!!!!>>
=  왼쪽의 피연산자에 오른쪽의 피연산자를 대입함.
+= 왼쪽의 피연산자에 오른쪽의 피연산자를 더한 후, 그 결괏값을 왼쪽의 피연산자에 대입함.
-=	왼쪽의 피연산자에서 오른쪽의 피연산자를 뺀 후, 그 결괏값을 왼쪽의 피연산자에 대입함.
*=	왼쪽의 피연산자에 오른쪽의 피연산자를 곱한 후, 그 결괏값을 왼쪽의 피연산자에 대입함.
/=	왼쪽의 피연산자를 오른쪽의 피연산자로 나눈 후, 그 결괏값을 왼쪽의 피연산자에 대입함.
%=	왼쪽의 피연산자를 오른쪽의 피연산자로 나눈 후, 그 나머지를 왼쪽의 피연산자에 대입함.
&=	왼쪽의 피연산자를 오른쪽의 피연산자와 비트 AND 연산한 후, 그 결괏값을 왼쪽의 피연산자에 대입함.
|=	왼쪽의 피연산자를 오른쪽의 피연산자와 비트 OR 연산한 후, 그 결괏값을 왼쪽의 피연산자에 대입함.
^=	왼쪽의 피연산자를 오른쪽의 피연산자와 비트 XOR 연산한 후, 그 결괏값을 왼쪽의 피연산자에 대입함.
<<=	왼쪽의 피연산자를 오른쪽의 피연산자만큼 왼쪽 시프트한 후, 그 결괏값을 왼쪽의 피연산자에 대입함.
>>=	왼쪽의 피연산자를 오른쪽의 피연산자만큼 부호를 유지하며 오른쪽 시프트한 후, 그 결괏값을 왼쪽의 피연산자에 대입함.
>>>=왼쪽의 피연산자를 오른쪽의 피연산자만큼 부호에 상관없이 오른쪽 시프트한 후, 그 결괏값을 왼쪽의 피연산자에 대입함.
++x	먼저 피연산자의 값을 1 증가시킨 후에 해당 연산을 진행함.
x++	먼저 해당 연산을 수행하고 나서, 피연산자의 값을 1 증가시킴.
--x	먼저 피연산자의 값을 1 감소시킨 후에 해당 연산을 진행함.
x--	먼저 해당 연산을 수행하고 나서, 피연산자의 값을 1 감소시킴.
==	왼쪽의 피연산자와 오른쪽의 피연산자가 같으면 참을 반환함.
!=	왼쪽의 피연산자와 오른쪽의 피연산자가 같지 않으면 참을 반환함.
>	왼쪽의 피연산자가 오른쪽의 피연산자보다 크면 참을 반환함.
>=	왼쪽의 피연산자가 오른쪽의 피연산자보다 크거나 같으면 참을 반환함.
<	왼쪽의 피연산자가 오른쪽의 피연산자보다 작으면 참을 반환함.
<=	왼쪽의 피연산자가 오른쪽의 피연산자보다 작거나 같으면 참을 반환함.

<논리 연산자>
&&	논리식이 모두 참이면 참을 반환함. (논리 AND 연산)
||	논리식 중에서 하나라도 참이면 참을 반환함. (논리 OR 연산)
!	논리식의 결과가 참이면 거짓을, 거짓이면 참을 반환함. (논리 NOT 연산)

<비트 연산자>
&	대응되는 비트가 모두 1이면 1을 반환함. (비트 AND 연산)
|	대응되는 비트 중에서 하나라도 1이면 1을 반환함. (비트 OR 연산)
^	대응되는 비트가 서로 다르면 1을 반환함. (비트 XOR 연산)
~	비트를 1이면 0으로, 0이면 1로 반전시킴. (비트 NOT 연산, 1의 보수)
<<	명시된 수만큼 비트들을 전부 왼쪽으로 이동시킴. (left shift 연산)
>>	부호를 유지하면서 지정한 수만큼 비트를 전부 오른쪽으로 이동시킴. (right shift 연산)
>>>	지정한 수만큼 비트를 전부 오른쪽으로 이동시키며, 새로운 비트는 전부 0이 됨.

<삼항 연산자(ternary operator)>
조건식 ? 반환값1 : 반환값2

<조건문(conditional statements)>
1. if 문
2. if / else 문
3. if / else if / else 문
4. switch 문

<if 문>
if 문은 조건식의 결과가 참(true)이면 주어진 명령문을 실행하며, 거짓(false)이면 아무것도 실행하지 않습니다.
							if (조건식) {
							 조건식의 결과가 참일 때 실행하고자 하는 명령문;
										}

	if (ch >= 'a' && ch <= 'z') {
		System.out.println("해당 문자는 영문 소문자입니다.");
		}

< if / else 문>
			if (조건식) {
				조건식의 결과가 참일 때 실행하고자 하는 명령문;
			} else {
				조건식의 결과가 거짓일 때 실행하고자 하는 명령문;
			}

					if (ch >= 'a' && ch <= 'z') {
						System.out.println("해당 문자는 영문 소문자입니다.");
					} else {
						System.out.println("해당 문자는 영문 소문자가 아닙니다.");
					}

<switch 문>
switch 문은 if / else 문과 마찬가지로 주어진 조건 값의 결과에 따라 프로그램이 다른 명령을 수행하도록 하는 조건문입니다.
이러한 switch 문은 if / else 문보다 가독성이 더 좋으며, 컴파일러가 최적화를 쉽게 할 수 있어 속도 또한 빠른 편입니다.
하지만 switch 문의 조건 값으로는 int형으로 승격할 수 있는(integer promotion) 값만이 사용될 수 있습니다.
즉, 자바에서는 swich 문의 조건 값으로 byte형, short형, char형, int형의 변수나 리터럴을 사용할 수 있습니다.
또한, 이러한 기본 타입에 해당하는 데이터를 객체로 포장해 주는 래퍼 클래스(Wrapper class) 중에서 위에 해당하는 Byte, Short, Character, Integer 클래스의 객체도 사용할 수 있습니다.
그리고 enum 키워드를 사용한 열거체(enumeration type)와 String 클래스의 객체도 사용할 수 있습니다.
따라서 switch 문은 if / else 문보다는 사용할 수 있는 상황이 적습니다.

		switch (조건 값) {
			case 값1:
				조건 값이 값1일 때 실행하고자 하는 명령문;
				break;
			case 값2:
				조건 값이 값2일 때 실행하고자 하는 명령문;
				break;
			...
			default:
				조건 값이 어떠한 case 절에도 해당하지 않을 때 실행하고자 하는 명령문;
				break;
		}
각 case 절 및 default 절은 반드시 break 키워드를 포함하고 있어야 합니다.

<반복문(iteration statements)>
반복문이란 프로그램 내에서 똑같은 명령을 일정 횟수만큼 반복하여 수행하도록 제어하는 명령문입니다.
프로그램이 처리하는 대부분의 코드는 반복적인 형태가 많으므로, 가장 많이 사용되는 제어문 중 하나입니다.
		1. while 문
					while (조건식) {
						조건식의 결과가 참인 동안 반복적으로 실행하고자 하는 명령문;
					}
		2. do / while 문
						do {
							조건식의 결과가 참인 동안 반복적으로 실행하고자 하는 명령문;
						} while (조건식);
		3. for 문
				for (초기식; 조건식; 증감식) {
					조건식의 결과가 참인 동안 반복적으로 실행하고자 하는 명령문;
				}

<break 문>
break 문은 루프 내에서 사용하여 해당 반복문을 완전히 종료시킨 뒤, 반복문 바로 다음에 위치한 명령문을 실행합니다.
즉 루프 내에서 조건식의 판단 결과와 상관없이 반복문을 완전히 빠져나가고 싶을 때 사용합니다.
				int num = 1, sum = 0;
				while (true) { // 무한 루프    sum += num;
					if (num == 100) {
						break;
					}
					num++;
				}
				System.out.println(sum);

<메소드(method) 영역>
메소드(method) 영역은 자바 프로그램에서 사용되는 클래스에 대한 정보와 함께 클래스 변수(static variable)가 저장되는 영역입니다.
JVM은 자바 프로그램에서 특정 클래스가 사용되면 해당 클래스의 클래스 파일(*.class)를 읽어들여, 해당 클래스에 대한 정보를 메소드 영역에 저장합니다.

힙(heap) 영역
힙(heap) 영역은 자바 프로그램에서 사용되는 모든 인스턴스 변수가 저장되는 영역입니다.
JVM은 자바 프로그램에서 new 키워드를 사용하여 인스턴스가 생성되면, 해당 인스턴스의 정보를 힙 영역에 저장합니다.
힙 영역은 메모리의 낮은 주소에서 높은 주소의 방향으로 할당됩니다.

<스택(stack) 영역>
스택(stack) 영역은 자바 프로그램에서 메소드가 호출될 때 메소드의 스택 프레임이 저장되는 영역입니다.


<배열(array)>
배열(array)은 같은 타입의 변수들로 이루어진 유한 집합으로 정의할 수 있습니다.
배열을 구성하는 각각의 값을 배열 요소(element)라고 하며, 배열에서의 위치를 가리키는 숫자를 인덱스(index)라고 합니다.
자바에서 인덱스는 언제나 0부터 시작하며, 0을 포함한 양의 정수만을 가질 수 있습니다.

<1차원 배열>
1차원 배열은 가장 기본적인 배열로 다음과 같은 문법에 따라 선언합니다.
	1. 타입[] 배열이름;
	2. 타입 배열이름[];
타입은 배열 요소로 저장되는 변수의 타입을 명시합니다.
배열 이름은 배열이 선언된 후에 배열에 접근하기 위해 사용됩니다.
자바에서는 배열을 만들기 위해 위의 두 가지 방법을 모두 사용할 수 있지만, 될 수 있으면 첫 번째 방법만을 사용하는 것이 좋습니다.
위와 같이 선언된 배열은 new 키워드를 사용하여 실제 배열로 생성할 수 있습니다.

	배열이름 = new 타입[배열길이];

배열의 길이는 해당 배열이 몇 개의 배열 요소를 가지게 되는지 명시합니다.
또한, 다음과 같이 배열의 선언과 생성을 동시에 할 수도 있습니다.

	타입[] 배열이름 = new 타입[배열길이];

자바에서는 이러한 배열도 모두 객체이므로, 각각의 배열은 모두 자신만의 필드와 메소드를 가지고 있습니다.
다음 예제는 int형 데이터를 3개 저장할 수 있는 배열을 선언과 동시에 생성하고 있습니다.

		int[] grade1 = new int[3]; // 길이가 3인 int형 배열의 선언 및 생성
		int[] grade2 = new int[3]; // 길이가 3인 int형 배열의 선언 및 생성
		grade1[0] = 85; // 인덱스를 이용한 배열의 초기화
		grade1[1] = 65;
		grade1[2] = 90;
		grade2[0] = 85; // 배열의 길이보다 적은 수의 배열 요소만 초기화
		for (int i = 0; i < grade1.length; i++) {
			System.out.print(grade1[i] + " "); // 인덱스를 이용한 배열로의 접근
		}
		for (int i = 0; i < grade2.length; i++) {
			System.out.print(grade2[i] + " "); // 인덱스를 이용한 배열로의 접근
		}

		실행 결과
		85 65 90
		85 0 0
위의 예제처럼 0부터 시작하는 인덱스(index)를 이용하면 각각의 배열 요소에 따로 접근할 수 있습니다.
또한, 배열 grade2처럼 배열의 길이보다 적은 수의 배열 요소만을 초기화할 경우,
나머지 배열 요소들은 배열의 타입에 맞게 자동으로 초기화될 것입니다.

<배열의 초기화>
자바에서는 변수와 마찬가지로 배열도 선언과 동시에 초기화할 수 있습니다.
		1. 타입[] 배열이름 = {배열요소1, 배열요소2, ...};
		2. 타입[] 배열이름 = new 타입[]{배열요소1, 배열요소2, ...};
위의 두 가지 초기화 방법은 완전히 같은 결과를 반환하며, 초기화 블록에 맞춰 자동으로 배열의 길이가 설정됩니다.
하지만 다음과 같은 경우에는 첫 번째 방법이 아닌 두 번째 방법만을 사용하여 초기화해야 합니다.
		1. 배열의 선언과 초기화를 따로 진행해야 할 경우
		2. 메소드의 인수로 배열을 전달하면서 초기화해야 할 경우
int[] grade = new int[]{85, 65, 90}; // 길이가 3인 int형 배열을 선언과 동시에 초기화
int sum = 0;
for (int i = 0; i < grade.length; i++) {
    sum += grade[i];
}
System.out.println("모든 과목에서 받은 점수의 합은 " + sum + "입니다.");
System.out.println("이 학생의 평균은 " + (sum / grade.length) + "입니다.");

<2차원 배열(two dimensional array)>
		1. 타입[][] 배열이름;
		2. 타입 배열이름[][];
		3. 타입[] 배열이름[];
int[][] arr = new int[2][3];
int k = 10;
for (int i = 0; i < arr.length; i++) {
    for (int j = 0; j < arr[i].length; j++) {
        arr[i][j] = k; // 인덱스를 이용한 초기화
        k += 10;
    }
}
for (int i = 0; i < arr.length; i++) {
    for (int j = 0; j < arr[i].length; j++) {
        System.out.print(arr[i][j] + " ");
    }
    System.out.println();
}
		실행 결과
		10 20 30
		40 50 60
위의 예제에서 사용된 arr는 2차원 배열이며, arr[i]는 arr의 각 배열 요소로 1차원 배열이 됩니다.
따라서 arr.length는 2차원 배열인 arr의 배열 요소의 총 개수를 반환하며,
arr[i].length는 arr의 각 배열 요소인 1차원 배열이 가지고 있는 배열 요소의 총 개수를 반환하게 됩니다.

<배열의 복사>
자바에서 배열은 한 번 생성하면 그 길이를 변경할 수 없습니다.
따라서 더 많은 데이터를 저장하기 위해서는 더욱 큰 배열을 만들고, 이전 배열의 데이터를 새로 만든 배열로 복사해야 합니다.
arraycopy(), copyOf() 메소드와 for 문을 이용한 복사는 배열의 길이를 마음대로 늘일 수 있습니다.
하지만 clone() 메소드는 이전 배열과 같은 길이의 배열밖에 만들 수 없습니다.

			int[] arr1 = new int[]{1, 2, 3, 4, 5};
			int newLen = 10;
			// 1. System 클래스의 arraycopy() 메소드
			int[] arr2 = new int[newLen];
			System.arraycopy(arr1, 0, arr2, 0, arr1.length);
			// 2. Arrays 클래스의 copyOf() 메소드
			int[] arr3 = Arrays.copyOf(arr1, 10);
			// 3. Object 클래스의 clone() 메소드
			int[] arr4 = (int[])arr1.clone();
			// 4. for 문과 인덱스를 이용한 복사
			int[] arr5 = new int[newLen];
						실행 결과
						1 2 3 4 5 0 0 0 0 0
						1 2 3 4 5 0 0 0 0 0
						1 2 3 4 5
						1 2 3 4 5 0 0 0 0 0




메소드(method)
자바에서 클래스는 멤버(member)로 속성을 표현하는 필드(field)와 기능을 표현하는 메소드(method)를 가집니다.
그중에서 메소드(method)란 어떠한 특정 작업을 수행하기 위한 명령문의 집합이라 할 수 있습니다.

메소드 정의
클래스에서 메소드를 정의하는 방법은 일반 함수를 정의하는 방법과 크게 다르지 않습니다.

1.접근제어자 2.반환타입 3.메소드이름(4.매개변수목록) {    <- 선언부
    //  <- 5.구현부
                    } <-마무리
----------------------------------------
class Car {

private int currentSpeed;
private int accelerationTime;

        public void accelerate(int speed, int second) { // 선언부
        // 구현부
        System.out.println(second + "초간 속도를 시속 " + speed + "(으)로 가속함!!");
    }
---------------------------------------
1. 접근 제어자 : 해당 메소드에 접근할 수 있는 범위를 명시합니다.
2. 반환 타입(return type) : 메소드가 모든 작업을 마치고 반환하는 데이터의 타입을 명시합니다.
3. 메소드 이름 : 메소드를 호출하기 위한 이름을 명시합니다.
4. 매개변수 목록(parameters) : 메소드 호출 시에 전달되는 인수의 값을 저장할 변수들을 명시합니다.
5. 구현부 : 메소드의 고유 기능을 수행하는 명령문의 집합입니다.

위 예제의 ①번 라인에서는 accelerate() 메소드를 정의하고 있습니다.
이 메소드는 public 접근 제어자를 사용하여 선언되어 해당 객체를 사용하는 프로그램 어디에서나 직접 접근할 수 있습니다.
반환 타입에는 어떠한 값도 반환하지 않는다는 의미를 가진 void를 명시합니다.
그 다음으로 메소드의 이름을 명시하고, 매개변수로 int형 변수인 speed와 second를 전달받습니다.
이렇게 전달받은 매개변수를 가지고 메소드 구현부에서 고유한 작업을 수행할 수 있는 것입니다.

메소드 호출
자바에서 위와 같은 방법으로 정의한 메소드는 멤버 참조 연산자(.)를 사용하여 호출할 수 있습니다.
    1. 객체참조변수이름.메소드이름();                  <- 매개변수가 없는 메소드의 호출
    2. 객체참조변수이름.메소드이름(인수1, 인수2, ...);   <- 매개변수가 있는 메소드의 호출

<메소드의 사용 목적>
클래스에서 메소드를 작성하여 중복되는 코드의 반복적인 프로그래밍을 피할 수 있기 때문입니다.
모듈화로 인해 코드의 가독성도 좋아집니다. 손쉽게 유지보수를 할 수 있게 됩니다.
메소드를 작성할 때는 되도록 하나의 메소드가 하나의 기능만을 수행하도록 작성하는 것이 좋습니다.
클래스의 메소드(method)란 어떠한 작업을 수행하기 위한 명령문의 집합이라 할 수 있습니다.
클래스 내에서 메소드는 static 키워드의 여부에 따라 다음과 같이 구분됩니다.

    1. 클래스 메소드(static method)
    2. 인스턴스 메소드(instance method)
static 키워드를 가지는 메소드를 클래스 메소드(static method)라고 합니다.
static 키워드를 가지지 않는 메소드는 인스턴스 메소드(instance method)라고 합니다.
클래스 메소드는 인스턴스 변수를 사용하지 않고, 전달된 매개변수만으로 동작하는 메소드입니다.

<toString() 메소드>
toString() 메소드는 해당 인스턴스에 대한 정보를 문자열로 반환합니다.
이때 반환되는 문자열은 클래스 이름과 함께 구분자로 '@'가 사용되며,
그 뒤로 16진수 해시 코드(hash code)가 추가됩니다.
16진수 해시 코드 값은 인스턴스의 주소를 가리키는 값으로, 인스턴스마다 모두 다르게 반환됩니다.

<charAt() 메소드>
charAt() 메소드는 해당 문자열의 특정 인덱스에 해당하는 문자를 반환합니다.
만약 해당 문자열의 길이보다 큰 인덱스나 음수를 전달하면,

        IndexOutOfBoundsException 오류가 발생합니다.
        String str = new String("Java");

        System.out.println("원본 문자열 : " + str);

        for (int i = 0; i < str.length(); i++) {

            System.out.print(str.charAt(i) + " ");
        }
        System.out.println("\ncharAt() 메소드 호출 후 원본 문자열 : " + str);







    1. 클래스이름() { ... } // 매개변수가 없는 생성자 선언
    2. 클래스이름(인수1, 인수2,...) { ... } // 매개변수가 있는 생성자 선언

<클래스의 선언>
클래스(class)란 객체 지향 프로그래밍의 추상화(abstraction)라는 개념을 직접 구현한 것이라 할 수 있습니다.
자바에서는 개발자의 편의를 위해 유용하게 사용할 수 있는 많은 수의 클래스를 미리 정의하여 제공하고 있습니다.
또한, 개발자가 원하는 동작을 하는 새로운 클래스를 손쉽게 작성할 수도 있습니다.
자바에서 클래스를 선언하는 방법은 접근 제어자와 함께 class 키워드를 사용하면 됩니다.

<인스턴스 변수의 초기화>
클래스를 가지고 객체를 생성하면, 해당 객체는 메모리에 즉시 생성됩니다.
하지만 이렇게 생성된 객체는 모든 인스턴스 변수가 아직 초기화되지 않은 상태입니다.
객체를 참조하기 위한 참조 변수를 먼저 선언합니다.
그 후에 new 키워드를 사용하여 인스턴스를 생성하고,
해당 인스턴스의 주소를 미리 선언한 참조 변수에 저장하여 사용합니다.

객체참조변수이름 = new 클래스이름();

또한, 다음과 같이 참조 변수의 선언과 인스턴스의 생성을 동시에 할 수도 있습니다.
Car myCar = new Car();

사용자가 원하는 값으로 인스턴스 변수를 초기화하려면, 일반적인 방식으로는 초기화할 수 없습니다.
인스턴스 변수 중에는 private 변수도 있으며,
private 변수에는 사용자나 프로그램이 직접 접근할 수 없기 때문입니다.
따라서 private 인스턴스 변수에도 접근할 수 있는 초기화만을 위한 public 메소드가 필요해집니다.
이러한 초기화만을 위한 메소드는 객체가 생성된 후부터 사용되기 전까지
반드시 인스턴스 변수의 초기화를 위해 호출되어야 합니다.

<기본 생성자(default constructor)>
자바의 모든 클래스에는 하나 이상의 '생성자' 가 정의되어 있어야 합니다.
but 자바 컴파일러가 '기본 생성자(default constructor)' 라는 것을 기본 제공하기 때문에
생성자를 정의하지 않고도 인스턴스를 생성할 수 있습니다.
'기본 생성자' 는 매개변수를 전혀 갖지 않고, 아무런 명령어도 포함하고 있지 않습니다.
자바 컴파일러는 컴파일 시 클래스에 생성자가 없으면 자동으로 기본 생성자를 추가합니다.
자바에서는 new 키워드를 사용하여 객체를 생성할 때 자동으로 생성자가 호출됩니다.


<this 참조 변수>
this 참조 변수는 인스턴스가 바로 자기 자신을 참조하는 데 사용하는 변수입니다.
this 참조 변수는 해당 인스턴스의 주소를 가리키고 있습니다.
생성자의 매개변수 이름과 인스턴스 변수의 이름이 같을 경우에는
인스턴스 변수 앞에 this 키워드를 붙여 구분해만 합니다.
this 참조 변수를 사용할 수 있는 영역은 인스턴스 메소드뿐이며,
클래스 메소드에서는 사용할 수 없습니다.

<static 제어자>
자바에서 static 제어자는 '공통적인' 이라는 의미로 사용됩니다.
static 제어자를 변수에 사용하면 해당 변수를 클래스 변수로 만들어 줍니다.
또한, 메소드에 사용하면 해당 메소드를 클래스 메소드로 만들어 줍니다.
이러한 static 제어자는 초기화 블록에도 사용할 수 있습니다.

    1. 프로그램 시작시 최초에 단 한 번만 생성되고 초기화됩니다.
    2. 인스턴스를 생성하지 않고도 바로 사용할 수 있게 됩니다.
    3. 해당 클래스의 모든 인스턴스가 공유합니다.


<필드의 구분>
클래스의 필드(field)란 클래스에 포함된 변수(variable)를 의미합니다.
클래스 내에서 필드는 선언된 위치에 따라 다음과 같이 구분됩니다.

    1. 클래스 변수(static variable)
    2. 인스턴스 변수(instance variable)
    3. 지역 변수(local variable)

class Car {
    static int modelOutput; // 클래스 변수
    String modelName;       // 인스턴스 변수
    void method() {
        int something = 10; // 지역 변수
    }
}

<클래스 변수와 인스턴스 변수>
클래스 영역에 위치한 변수 중에서 static 키워드를 가지는 변수를 클래스 변수(static variable)라고 합니다.
그리고 클래스 영역에 위치한 변수 중 static 키워드를 가지지 않는 변수는 인스턴스 변수(instance variable)라고 합니다.
또한, 메소드나 생성자, 초기화 블록 내에 위치한 변수를 지역 변수(local variable)라고 합니다.


<Math 클래스>
java.lang.Math 클래스
Math 클래스는 수학에서 자주 사용하는 상수들과 함수들을 미리 구현해 놓은 클래스입니다.
Math 클래스의 모든 메소드는 클래스 메소드(static method)이므로, 객체를 생성하지 않고도 바로 사용할 수 있습니다.
이러한 Math 클래스는 java.lang 패키지에 포함되어 제공됩니다.

    1. Math.E : 오일러의 수라 불리며, 자연로그(natural logarithms)의
                밑(base) 값으로 약 2.718을 의미합니다.
    2. Math.PI : 원의 원주를 지름으로 나눈 비율(원주율) 값으로 약 3.14159를 의미합니다.

<random() 메소드>
random() 메소드는 0.0 이상 1.0 미만의 범위에서 임의의 double 형 값을 하나 생성하여 반환합니다.
이 메소드는 내부적으로 java.util 패키지의 Random 클래스를 사용한
의사 난수 발생기(pseudorandom-number generator)를 사용하여 임의의 수를 생성합니다.

    System.out.println((int)(Math.random() * 100)); // 0 ~ 99
    Random ran = new Random();
    System.out.println(ran.nextInt(100));           // 0 ~ 99
                            or
    (int)(Math.random() * 6);       // 0 ~ 5
    ((int)(Math.random() * 6) + 1); // 1 ~ 6
    ((int)(Math.random() * 6) + 3); // 3 ~ 8

<pow() 메소드와 sqrt() 메소드>
pow() 메소드는 전달된 두 개의 double형 값을 가지고 제곱 연산을 수행합니다.
예를 들어, pow(a, b)는 a의 b 승을 반환하게 됩니다.
반대로 sqrt() 메소드는 전달된 double형 값의 제곱근 값을 반환합니다.

            System.out.println((int)Math.pow(5, 2)); // 25
            System.out.println((int)Math.sqrt(25));  // 5

            실행 결과
            25
            5




 */

